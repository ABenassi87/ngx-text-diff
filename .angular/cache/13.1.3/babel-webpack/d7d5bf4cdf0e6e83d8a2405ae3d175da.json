{"ast":null,"code":"'use strict';\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n\n  var LongStackTrace =\n  /** @class */\n  function () {\n    function LongStackTrace() {\n      this.error = getStacktrace();\n      this.timestamp = new Date();\n    }\n\n    return LongStackTrace;\n  }();\n\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  } // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n\n\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n\n    if (frames) {\n      var timestamp = new Date().getTime();\n\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n\n    return longTrace.join(NEWLINE);\n  } // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function (error) {\n      if (!error) {\n        return undefined;\n      }\n\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n      if (!trace) {\n        return error.stack;\n      }\n\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n\n        if (!task.data) task.data = {};\n\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = Object.assign({}, task.data);\n        }\n\n        task.data[creationTrace] = trace;\n      }\n\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      var frame2 = frames2[i];\n\n      if (frame1 === frame2) {\n        IGNORE_FRAMES[frame1] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  computeIgnoreFrames();\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ProxyZoneSpec =\n  /** @class */\n  function () {\n    function ProxyZoneSpec(defaultSpecDelegate) {\n      if (defaultSpecDelegate === void 0) {\n        defaultSpecDelegate = null;\n      }\n\n      this.defaultSpecDelegate = defaultSpecDelegate;\n      this.name = 'ProxyZone';\n      this._delegateSpec = null;\n      this.properties = {\n        'ProxyZoneSpec': this\n      };\n      this.propertyKeys = null;\n      this.lastTaskState = null;\n      this.isNeedToTriggerHasTask = false;\n      this.tasks = [];\n      this.setDelegate(defaultSpecDelegate);\n    }\n\n    ProxyZoneSpec.get = function () {\n      return Zone.current.get('ProxyZoneSpec');\n    };\n\n    ProxyZoneSpec.isLoaded = function () {\n      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    };\n\n    ProxyZoneSpec.assertPresent = function () {\n      if (!ProxyZoneSpec.isLoaded()) {\n        throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n      }\n\n      return ProxyZoneSpec.get();\n    };\n\n    ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n      var _this = this;\n\n      var isNewDelegate = this._delegateSpec !== delegateSpec;\n      this._delegateSpec = delegateSpec;\n      this.propertyKeys && this.propertyKeys.forEach(function (key) {\n        return delete _this.properties[key];\n      });\n      this.propertyKeys = null;\n\n      if (delegateSpec && delegateSpec.properties) {\n        this.propertyKeys = Object.keys(delegateSpec.properties);\n        this.propertyKeys.forEach(function (k) {\n          return _this.properties[k] = delegateSpec.properties[k];\n        });\n      } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n        this.isNeedToTriggerHasTask = true;\n      }\n    };\n\n    ProxyZoneSpec.prototype.getDelegate = function () {\n      return this._delegateSpec;\n    };\n\n    ProxyZoneSpec.prototype.resetDelegate = function () {\n      var delegateSpec = this.getDelegate();\n      this.setDelegate(this.defaultSpecDelegate);\n    };\n\n    ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n      if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n        // last delegateSpec has microTask or macroTask\n        // should call onHasTask in current delegateSpec\n        this.isNeedToTriggerHasTask = false;\n        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n      }\n    };\n\n    ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n      if (!this.tasks) {\n        return;\n      }\n\n      for (var i = 0; i < this.tasks.length; i++) {\n        if (this.tasks[i] === task) {\n          this.tasks.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n      if (this.tasks.length === 0) {\n        return '';\n      }\n\n      var taskInfo = this.tasks.map(function (task) {\n        var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n          return key + ':' + task.data[key];\n        }).join(',');\n        return \"type: \" + task.type + \", source: \" + task.source + \", args: {\" + dataInfo + \"}\";\n      });\n      var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n      this.tasks = [];\n      return pendingTasksInfo;\n    };\n\n    ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n      if (this._delegateSpec && this._delegateSpec.onFork) {\n        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n      } else {\n        return parentZoneDelegate.fork(targetZone, zoneSpec);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n      if (this._delegateSpec && this._delegateSpec.onIntercept) {\n        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n      } else {\n        return parentZoneDelegate.intercept(targetZone, delegate, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvoke) {\n        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n      } else {\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (this._delegateSpec && this._delegateSpec.onHandleError) {\n        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n      } else {\n        return parentZoneDelegate.handleError(targetZone, error);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.tasks.push(task);\n      }\n\n      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n      } else {\n        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.cancelTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n      this.lastTaskState = hasTaskState;\n\n      if (this._delegateSpec && this._delegateSpec.onHasTask) {\n        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n      } else {\n        delegate.hasTask(target, hasTaskState);\n      }\n    };\n\n    return ProxyZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var SyncTestZoneSpec =\n  /** @class */\n  function () {\n    function SyncTestZoneSpec(namePrefix) {\n      this.runZone = Zone.current;\n      this.name = 'syncTestZone for ' + namePrefix;\n    }\n\n    SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n        case 'macroTask':\n          throw new Error(\"Cannot call \" + task.source + \" from within a sync test.\");\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    };\n\n    return SyncTestZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n\n    var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors_1 = jasmine.GlobalErrors;\n\n      if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors_1;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors_1();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var originalHandlers = process.listeners('unhandledRejection');\n              var r = originalInstall.apply(this, arguments);\n              process.removeAllListeners('unhandledRejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (h) {\n                  return process.on('unhandledRejection', h);\n                });\n              }\n\n              return r;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn_1 = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn_1.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick_1 = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick_1.apply(this, arguments);\n          };\n\n          var originalMockDate_1 = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate_1.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    } // monkey patch createSpyObj to make properties enumerable to true\n\n\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj_1 = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n\n        if (propertyNames) {\n          var defineProperty_1 = Object.defineProperty;\n\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n\n          try {\n            spyObj = originalCreateSpyObj_1.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty_1;\n          }\n        } else {\n          spyObj = originalCreateSpyObj_1.apply(this, args);\n        }\n\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('jest', function (context, Zone, api) {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n      return;\n    }\n\n    jest['__zone_patch__'] = true;\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    var proxyZoneSpec = new ProxyZoneSpec();\n    var proxyZone = rootZone.fork(proxyZoneSpec);\n\n    function wrapDescribeFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapDescribeInZone(args[1]);\n          return originalDescribeFn.apply(this, args);\n        };\n      };\n    }\n\n    function wrapTestFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapTestInZone(args[1]);\n          return originalJestFn.apply(this, tableArgs).apply(this, args);\n        };\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return syncZone.run(describeBody, this, args);\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n\n\n    function wrapTestInZone(testBody, isTestFunc) {\n      if (isTestFunc === void 0) {\n        isTestFunc = false;\n      }\n\n      if (typeof testBody !== 'function') {\n        return testBody;\n      }\n\n      var wrappedFunc = function () {\n        if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n          // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n          var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n          if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n            testBody = fakeAsyncModule.fakeAsync(testBody);\n          }\n        }\n\n        proxyZoneSpec.isTestFunc = isTestFunc;\n        return proxyZone.run(testBody, null, arguments);\n      }; // Update the length of wrappedFunc to be the same as the length of the testBody\n      // So jest core can handle whether the test function has `done()` or not correctly\n\n\n      Object.defineProperty(wrappedFunc, 'length', {\n        configurable: true,\n        writable: true,\n        enumerable: false\n      });\n      wrappedFunc.length = testBody.length;\n      return wrappedFunc;\n    }\n\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapTestInZone(args[1], true);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n      context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[0] = wrapTestInZone(args[0]);\n        return originalJestFn.apply(this, args);\n      };\n    });\n\n    Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n      if (isModern === void 0) {\n        isModern = false;\n      } // check whether currently the test is inside fakeAsync()\n\n\n      function isPatchingFakeTimer() {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        return !!fakeAsyncZoneSpec;\n      } // check whether the current function is inside `test/it` or other methods\n      // such as `describe/beforeEach`\n\n\n      function isInTestFunc() {\n        var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n        return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n      }\n\n      if (Timer[api.symbol('fakeTimers')]) {\n        return;\n      }\n\n      Timer[api.symbol('fakeTimers')] = true; // patch jest fakeTimer internal method to make sure no console.warn print out\n\n      api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n        return function (self, args) {\n          if (isPatchingFakeTimer()) {\n            return true;\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n\n      api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = true;\n\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n\n          return self;\n        };\n      }); // patch useRealTimers(), unset useFakeTimers flag\n\n      api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = false;\n\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n\n          return self;\n        };\n      }); // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            return fakeAsyncZoneSpec.getRealSystemTime();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runAllTicks(), run all microTasks inside fakeAsync\n\n      api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushMicrotasks();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runAllTimers(), run all macroTasks inside fakeAsync\n\n      api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flush(100, true);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tick(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushOnlyPendingTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tickToNext(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.removeAllTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.getTimerCount();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n    };\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('mocha', function (global, Zone) {\n    var Mocha = global.Mocha;\n\n    if (typeof Mocha === 'undefined') {\n      // return if Mocha is not available, because now zone-testing\n      // will load mocha patch with jasmine/jest patch\n      return;\n    }\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    if (Mocha['__zone_patch__']) {\n      throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n\n    Mocha['__zone_patch__'] = true;\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    var testZone = null;\n    var suiteZone = rootZone.fork(new ProxyZoneSpec());\n    var mochaOriginal = {\n      after: Mocha.after,\n      afterEach: Mocha.afterEach,\n      before: Mocha.before,\n      beforeEach: Mocha.beforeEach,\n      describe: Mocha.describe,\n      it: Mocha.it\n    };\n\n    function modifyArguments(args, syncTest, asyncTest) {\n      var _loop_1 = function (i) {\n        var arg = args[i];\n\n        if (typeof arg === 'function') {\n          // The `done` callback is only passed through if the function expects at\n          // least one argument.\n          // Note we have to make a function with correct number of arguments,\n          // otherwise mocha will\n          // think that all functions are sync or async.\n          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n          // correct function body\n\n          args[i].toString = function () {\n            return arg.toString();\n          };\n        }\n      };\n\n      for (var i = 0; i < args.length; i++) {\n        _loop_1(i);\n      }\n\n      return args;\n    }\n\n    function wrapDescribeInZone(args) {\n      var syncTest = function (fn) {\n        return function () {\n          return syncZone.run(fn, this, arguments);\n        };\n      };\n\n      return modifyArguments(args, syncTest);\n    }\n\n    function wrapTestInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return testZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function (fn) {\n        return function () {\n          return testZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    function wrapSuiteInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return suiteZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function (fn) {\n        return function () {\n          return suiteZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    global.describe = global.suite = Mocha.describe = function () {\n      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.describe.only = global.suite.only = Mocha.describe.only = function () {\n      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.it = global.specify = global.test = Mocha.it = function () {\n      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.xit = global.xspecify = Mocha.it.skip = function () {\n      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.it.only = global.test.only = Mocha.it.only = function () {\n      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.after = global.suiteTeardown = Mocha.after = function () {\n      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.afterEach = global.teardown = Mocha.afterEach = function () {\n      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.before = global.suiteSetup = Mocha.before = function () {\n      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.beforeEach = global.setup = Mocha.beforeEach = function () {\n      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    (function (originalRunTest, originalRun) {\n      Mocha.Runner.prototype.runTest = function (fn) {\n        var _this = this;\n\n        Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n          originalRunTest.call(_this, fn);\n        });\n      };\n\n      Mocha.Runner.prototype.run = function (fn) {\n        this.on('test', function (e) {\n          testZone = rootZone.fork(new ProxyZoneSpec());\n        });\n        this.on('fail', function (test, err) {\n          var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n          if (proxyZoneSpec && err) {\n            try {\n              // try catch here in case err.message is not writable\n              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n            } catch (error) {}\n          }\n        });\n        return originalRun.call(this, fn);\n      };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (_global) {\n    var AsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n      };\n\n      AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this;\n\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We do this because we would like to catch unhandled rejected promises.\n          this.runZone.run(function () {\n            setTimeout(function () {\n              if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                _this.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n\n        return delegate.scheduleTask(target, task);\n      };\n\n      AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      };\n\n      AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.cancelTask(target, task);\n      }; // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n\n\n      AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          var afterTaskCounts = parentZoneDelegate._taskCounts;\n\n          if (this._isSync) {\n            this._finishCallbackIfDone();\n          }\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n\n        return false;\n      };\n\n      AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState);\n\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n\n          this._finishCallbackIfDone();\n        }\n      };\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function () {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // sill this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler =\n    /** @class */\n    function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTickTime = 0; // Current fake system base time in millis.\n\n        this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTickTime = function () {\n        return this._currentTickTime;\n      };\n\n      Scheduler.prototype.getFakeSystemTime = function () {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      };\n\n      Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      };\n\n      Scheduler.prototype.getRealSystemTime = function () {\n        return OriginalDate.now();\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.removeAll = function () {\n        this._schedulerQueue = [];\n      };\n\n      Scheduler.prototype.getTimerCount = function () {\n        return this._schedulerQueue.length;\n      };\n\n      Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n        if (step === void 0) {\n          step = 1;\n        }\n\n        if (this._schedulerQueue.length < step) {\n          return;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTickTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n        return this._scheduler.getCurrentTickTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n        return this._scheduler.getFakeSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n        return this._scheduler.getRealSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n        if (steps === void 0) {\n          steps = 1;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        if (steps <= 0) {\n          return;\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function () {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        this._scheduler.removeAll();\n\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n    function getProxyZoneSpec() {\n      return Zone && Zone['ProxyZoneSpec'];\n    }\n\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      var fakeAsyncFn = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var ProxyZoneSpec = getProxyZoneSpec();\n\n        if (!ProxyZoneSpec) {\n          throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n\n      fakeAsyncFn.isFakeAsync = true;\n      return fakeAsyncFn;\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  }, true);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * Promise for async/fakeAsync zoneSpec test\n   * can support async operation which not supported by zone.js\n   * such as\n   * it ('test jsonp in AsyncZone', async() => {\n   *   new Promise(res => {\n   *     jsonp(url, (data) => {\n   *       // success callback\n   *       res(data);\n   *     });\n   *   }).then((jsonpResult) => {\n   *     // get jsonp result.\n   *\n   *     // user will expect AsyncZoneSpec wait for\n   *     // then, but because jsonp is not zone aware\n   *     // AsyncZone will finish before then is called.\n   *   });\n   * });\n   */\n\n\n  Zone.__load_patch('promisefortest', function (global, Zone, api) {\n    var symbolState = api.symbol('state');\n    var UNRESOLVED = null;\n    var symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        return;\n      }\n\n      oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n      Promise.prototype.then = function () {\n        var chained = oriThen.apply(this, arguments);\n\n        if (this[symbolState] === UNRESOLVED) {\n          // parent promise is unresolved.\n          var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n          if (asyncTestZoneSpec) {\n            asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n            chained[symbolParentUnresolved] = true;\n          }\n        }\n\n        return chained;\n      };\n    };\n\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n      // restore origin then\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        Promise.prototype.then = oriThen;\n        Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n      }\n    };\n  });\n});","map":{"version":3,"sources":["C:/Users/Nacht/Desktop/ngx-text-diff/node_modules/zone.js/dist/zone-testing.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","factory","define","amd","NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","concat","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","get","current","isLoaded","assertPresent","prototype","delegateSpec","_this","isNewDelegate","forEach","key","keys","macroTask","microTask","getDelegate","resetDelegate","tryTriggerHasTask","onHasTask","removeFromTasks","splice","getAndClearPendingTasksInfo","taskInfo","map","dataInfo","source","pendingTasksInfo","onFork","zoneSpec","fork","onIntercept","delegate","intercept","onInvoke","applyThis","applyArgs","invoke","onInvokeTask","invokeTask","onCancelTask","cancelTask","target","hasTaskState","hasTask","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","p","__","constructor","create","jest","jasmine","ambientZone","syncZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors_1","GlobalErrors","instance","originalInstall","install","originalHandlers","process","listeners","apply","removeAllListeners","h","on","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","call","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn_1","clock","originalTick_1","tick","fakeAsyncZoneSpec","originalMockDate_1","mockDate","dateTime","setFakeBaseSystemTime","originalClockFn","FakeAsyncTestZoneSpec","originalCreateSpyObj_1","createSpyObj","args","slice","propertyNames","spyObj","defineProperty_1","defineProperty","obj","attributes","configurable","enumerable","describeBody","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","_i","originalDescribeFn","wrapTestFactoryInZone","isTestFunc","wrappedFunc","isFakeAsync","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","patchJestObject","Timer","isModern","isPatchingFakeTimer","isInTestFunc","patchMethod","self","getRealSystemTime","flushMicrotasks","flush","flushOnlyPendingTimers","tickToNext","removeAllTimers","getTimerCount","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","_loop_1","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","_finishCallbackIfDone","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","afterTaskCounts","_taskCounts","result","change","window","fail","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","bind","fakeAsyncTestZoneSpec","getFakeSystemTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","fakeBaseSystemTime","scheduleFunction","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","removeScheduledFunctionWithId","removeAll","step","doTick","tickOptions","startTime","targetTask","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","retval","lastTask","limit","flushPeriodic","flushNonPeriodic","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","assertInZone","_fnAndFlush","completers","onSuccess","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","elapsed","additionalArgs","callbackIndex","cbIdx","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","handleId","callback","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","fakeAsyncFn","res","lastProxyZoneSpec","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"mappings":"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","sourcesContent":["'use strict';\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var NEWLINE = '\\n';\n    var IGNORE_FRAMES = {};\n    var creationTrace = '__creationTrace__';\n    var ERROR_TAG = 'STACKTRACE TRACKING';\n    var SEP_TAG = '__SEP_TAG__';\n    var sepTemplate = SEP_TAG + '@[native]';\n    var LongStackTrace = /** @class */ (function () {\n        function LongStackTrace() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n        return LongStackTrace;\n    }());\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    var error = getStacktraceWithUncaughtError();\n    var caughtError = getStacktraceWithCaughtError();\n    var getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        var trace = getFrames(error);\n        for (var i = 0; i < trace.length; i++) {\n            var frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        var longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            var timestamp = new Date().getTime();\n            for (var i = 0; i < frames.length; i++) {\n                var traceFrames = frames[i];\n                var lastTime = traceFrames.timestamp;\n                var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                var currentTask = Zone.currentTask;\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = Object.assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                var parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        var frames = [];\n        captureStackTraces(frames, 2);\n        var frames1 = frames[0];\n        var frames2 = frames[1];\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                var match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            var frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ProxyZoneSpec = /** @class */ (function () {\n        function ProxyZoneSpec(defaultSpecDelegate) {\n            if (defaultSpecDelegate === void 0) { defaultSpecDelegate = null; }\n            this.defaultSpecDelegate = defaultSpecDelegate;\n            this.name = 'ProxyZone';\n            this._delegateSpec = null;\n            this.properties = { 'ProxyZoneSpec': this };\n            this.propertyKeys = null;\n            this.lastTaskState = null;\n            this.isNeedToTriggerHasTask = false;\n            this.tasks = [];\n            this.setDelegate(defaultSpecDelegate);\n        }\n        ProxyZoneSpec.get = function () {\n            return Zone.current.get('ProxyZoneSpec');\n        };\n        ProxyZoneSpec.isLoaded = function () {\n            return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n        };\n        ProxyZoneSpec.assertPresent = function () {\n            if (!ProxyZoneSpec.isLoaded()) {\n                throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n            }\n            return ProxyZoneSpec.get();\n        };\n        ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n            var _this = this;\n            var isNewDelegate = this._delegateSpec !== delegateSpec;\n            this._delegateSpec = delegateSpec;\n            this.propertyKeys && this.propertyKeys.forEach(function (key) { return delete _this.properties[key]; });\n            this.propertyKeys = null;\n            if (delegateSpec && delegateSpec.properties) {\n                this.propertyKeys = Object.keys(delegateSpec.properties);\n                this.propertyKeys.forEach(function (k) { return _this.properties[k] = delegateSpec.properties[k]; });\n            }\n            // if a new delegateSpec was set, check if we need to trigger hasTask\n            if (isNewDelegate && this.lastTaskState &&\n                (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n                this.isNeedToTriggerHasTask = true;\n            }\n        };\n        ProxyZoneSpec.prototype.getDelegate = function () {\n            return this._delegateSpec;\n        };\n        ProxyZoneSpec.prototype.resetDelegate = function () {\n            var delegateSpec = this.getDelegate();\n            this.setDelegate(this.defaultSpecDelegate);\n        };\n        ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n            if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n                // last delegateSpec has microTask or macroTask\n                // should call onHasTask in current delegateSpec\n                this.isNeedToTriggerHasTask = false;\n                this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n            }\n        };\n        ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n            if (!this.tasks) {\n                return;\n            }\n            for (var i = 0; i < this.tasks.length; i++) {\n                if (this.tasks[i] === task) {\n                    this.tasks.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n            if (this.tasks.length === 0) {\n                return '';\n            }\n            var taskInfo = this.tasks.map(function (task) {\n                var dataInfo = task.data &&\n                    Object.keys(task.data)\n                        .map(function (key) {\n                        return key + ':' + task.data[key];\n                    })\n                        .join(',');\n                return \"type: \" + task.type + \", source: \" + task.source + \", args: {\" + dataInfo + \"}\";\n            });\n            var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n            // clear tasks\n            this.tasks = [];\n            return pendingTasksInfo;\n        };\n        ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n            if (this._delegateSpec && this._delegateSpec.onFork) {\n                return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n            }\n            else {\n                return parentZoneDelegate.fork(targetZone, zoneSpec);\n            }\n        };\n        ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n            if (this._delegateSpec && this._delegateSpec.onIntercept) {\n                return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n            }\n            else {\n                return parentZoneDelegate.intercept(targetZone, delegate, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvoke) {\n                return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n            }\n            else {\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (this._delegateSpec && this._delegateSpec.onHandleError) {\n                return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n            }\n            else {\n                return parentZoneDelegate.handleError(targetZone, error);\n            }\n        };\n        ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.tasks.push(task);\n            }\n            if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n                return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.scheduleTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n                return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n            }\n            else {\n                return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n            }\n        };\n        ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n                return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.cancelTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n            this.lastTaskState = hasTaskState;\n            if (this._delegateSpec && this._delegateSpec.onHasTask) {\n                this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n            }\n            else {\n                delegate.hasTask(target, hasTaskState);\n            }\n        };\n        return ProxyZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var SyncTestZoneSpec = /** @class */ (function () {\n        function SyncTestZoneSpec(namePrefix) {\n            this.runZone = Zone.current;\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(\"Cannot call \" + task.source + \" from within a sync test.\");\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        };\n        return SyncTestZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', function (global, Zone, api) {\n        var __extends = function (d, b) {\n            for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        var ambientZone = Zone.current;\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe` but outside of\n        // a `beforeEach` or `it`.\n        var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n        var symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            var globalErrors_1 = jasmine.GlobalErrors;\n            if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors_1;\n                jasmine.GlobalErrors = function () {\n                    var instance = new globalErrors_1();\n                    var originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            var originalHandlers = process.listeners('unhandledRejection');\n                            var r = originalInstall.apply(this, arguments);\n                            process.removeAllListeners('unhandledRejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(function (h) { return process.on('unhandledRejection', h); });\n                            }\n                            return r;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        var jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            var originalClockFn_1 = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                var clock = originalClockFn_1.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    var originalTick_1 = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick_1.apply(this, arguments);\n                    };\n                    var originalMockDate_1 = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate_1.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(function (methodName) {\n                            var originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            var originalCreateSpyObj_1 = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n            jasmine.createSpyObj = function () {\n                var args = Array.prototype.slice.call(arguments);\n                var propertyNames = args.length >= 3 ? args[2] : null;\n                var spyObj;\n                if (propertyNames) {\n                    var defineProperty_1 = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj_1.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty_1;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj_1.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n            var testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        var QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                var _this = this;\n                if (attrs.onComplete) {\n                    attrs.onComplete = (function (fn) { return function () {\n                        // All functions are done, clear the test zone.\n                        _this.testProxyZone = null;\n                        _this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    }; })(attrs.onComplete);\n                }\n                var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                var onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        var proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                var _this = this;\n                var zone = Zone.current;\n                var isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () { return QueueRunner.prototype.execute.call(_this); });\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jest', function (context, Zone, api) {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        jest['__zone_patch__'] = true;\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        var proxyZoneSpec = new ProxyZoneSpec();\n        var proxyZone = rootZone.fork(proxyZoneSpec);\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapTestInZone(args[1]);\n                    return originalJestFn.apply(this, tableArgs).apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `proxyZone`.\n         */\n        function wrapTestInZone(testBody, isTestFunc) {\n            if (isTestFunc === void 0) { isTestFunc = false; }\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            var wrappedFunc = function () {\n                if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody &&\n                    !testBody.isFakeAsync) {\n                    // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                    var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                    if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                        testBody = fakeAsyncModule.fakeAsync(testBody);\n                    }\n                }\n                proxyZoneSpec.isTestFunc = isTestFunc;\n                return proxyZone.run(testBody, null, arguments);\n            };\n            // Update the length of wrappedFunc to be the same as the length of the testBody\n            // So jest core can handle whether the test function has `done()` or not correctly\n            Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n            wrappedFunc.length = testBody.length;\n            return wrappedFunc;\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapTestInZone(args[1], true);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n        Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n            if (isModern === void 0) { isModern = false; }\n            // check whether currently the test is inside fakeAsync()\n            function isPatchingFakeTimer() {\n                var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                return !!fakeAsyncZoneSpec;\n            }\n            // check whether the current function is inside `test/it` or other methods\n            // such as `describe/beforeEach`\n            function isInTestFunc() {\n                var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n                return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n            }\n            if (Timer[api.symbol('fakeTimers')]) {\n                return;\n            }\n            Timer[api.symbol('fakeTimers')] = true;\n            // patch jest fakeTimer internal method to make sure no console.warn print out\n            api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n                return function (self, args) {\n                    if (isPatchingFakeTimer()) {\n                        return true;\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n            api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = true;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch useRealTimers(), unset useFakeTimers flag\n            api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = false;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        return fakeAsyncZoneSpec.getRealSystemTime();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTicks(), run all microTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushMicrotasks();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTimers(), run all macroTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flush(100, true);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tick(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tickToNext(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.removeAllTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.getTimerCount();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n        };\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('mocha', function (global, Zone) {\n        var Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        var testZone = null;\n        var suiteZone = rootZone.fork(new ProxyZoneSpec());\n        var mochaOriginal = {\n            after: Mocha.after,\n            afterEach: Mocha.afterEach,\n            before: Mocha.before,\n            beforeEach: Mocha.beforeEach,\n            describe: Mocha.describe,\n            it: Mocha.it\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            var _loop_1 = function (i) {\n                var arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () {\n                        return arg.toString();\n                    };\n                }\n            };\n            for (var i = 0; i < args.length; i++) {\n                _loop_1(i);\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            var syncTest = function (fn) {\n                return function () {\n                    return syncZone.run(fn, this, arguments);\n                };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return testZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return testZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return suiteZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return suiteZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = Mocha.describe = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n            return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.describe.only = global.suite.only = Mocha.describe.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it = global.specify = global.test = Mocha.it = function () {\n            return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n        };\n        global.xit = global.xspecify = Mocha.it.skip = function () {\n            return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n        };\n        global.it.only = global.test.only = Mocha.it.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = Mocha.after = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = Mocha.afterEach = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = Mocha.before = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = Mocha.beforeEach = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        (function (originalRunTest, originalRun) {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                var _this = this;\n                Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n                    originalRunTest.call(_this, fn);\n                });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', function (e) {\n                    testZone = rootZone.fork(new ProxyZoneSpec());\n                });\n                this.on('fail', function (test, err) {\n                    var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) {\n                        }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        var AsyncTestZoneSpec = /** @class */ (function () {\n            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n                return this.unresolvedChainedPromiseCount > 0;\n            };\n            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n                var _this = this;\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We do this because we would like to catch unhandled rejected promises.\n                    this.runZone.run(function () {\n                        setTimeout(function () {\n                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                                _this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            };\n            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            };\n            AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            };\n            AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            };\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    var afterTaskCounts = parentZoneDelegate._taskCounts;\n                    if (this._isSync) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            };\n            AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                var result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            };\n            AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            };\n            return AsyncTestZoneSpec;\n        }());\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n    Zone.__load_patch('asynctest', function (global, Zone, api) {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, function (err) {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var _this = this;\n                return new Promise(function (finishCallback, failCallback) {\n                    runInTestZone(fn, _this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            var currentZone = Zone.current;\n            var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/async-test.js');\n            }\n            var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/proxy.js');\n            }\n            var proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            var previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(function () {\n                var testZoneSpec = new AsyncTestZoneSpec(function () {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // sill this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        finishCallback();\n                    });\n                }, function (error) {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                var d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                var args = Array.prototype.slice.call(arguments);\n                return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n            }\n        }\n        FakeDate.now = function () {\n            var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncTestZoneSpec) {\n                return fakeAsyncTestZoneSpec.getFakeSystemTime();\n            }\n            return OriginalDate.now.apply(this, arguments);\n        };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTickTime = 0;\n                // Current fake system base time in millis.\n                this._currentFakeBaseSystemTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTickTime = function () {\n                return this._currentTickTime;\n            };\n            Scheduler.prototype.getFakeSystemTime = function () {\n                return this._currentFakeBaseSystemTime + this._currentTickTime;\n            };\n            Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n                this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n            };\n            Scheduler.prototype.getRealSystemTime = function () {\n                return OriginalDate.now();\n            };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTickTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.removeAll = function () {\n                this._schedulerQueue = [];\n            };\n            Scheduler.prototype.getTimerCount = function () {\n                return this._schedulerQueue.length;\n            };\n            Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n                if (step === void 0) { step = 1; }\n                if (this._schedulerQueue.length < step) {\n                    return;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var targetTask = this._schedulerQueue[step - 1];\n                this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTickTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTickTime;\n                        this._currentTickTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTickTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTickTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTickTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n                return this._scheduler.getCurrentTickTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n                return this._scheduler.getFakeSystemTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n                this._scheduler.setFakeBaseSystemTime(realTime);\n            };\n            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n                return this._scheduler.getRealSystemTime();\n            };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n                if (steps === void 0) { steps = 1; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                if (steps <= 0) {\n                    return;\n                }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tickToNext(steps, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this._scheduler.removeAll();\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n            };\n            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n                return this._scheduler.getTimerCount() + this._microtasks.length;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        function getProxyZoneSpec() {\n            return Zone && Zone['ProxyZoneSpec'];\n        }\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            var fakeAsyncFn = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var ProxyZoneSpec = getProxyZoneSpec();\n                if (!ProxyZoneSpec) {\n                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                        'Please make sure that your environment includes zone.js/dist/proxy.js');\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n            fakeAsyncFn.isFakeAsync = true;\n            return fakeAsyncFn;\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            var pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };\n    }, true);\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', function (global, Zone, api) {\n        var symbolState = api.symbol('state');\n        var UNRESOLVED = null;\n        var symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                var chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n})));\n"]},"metadata":{},"sourceType":"script"}