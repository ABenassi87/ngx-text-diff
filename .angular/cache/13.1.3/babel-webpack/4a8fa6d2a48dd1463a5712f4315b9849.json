{"ast":null,"code":"import { ElementRef, EventEmitter, forwardRef, KeyValueDiffer, KeyValueDiffers, NgZone } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"ref\"];\n\nfunction normalizeLineEndings(str) {\n  if (!str) {\n    return str;\n  }\n\n  return str.replace(/\\r\\n|\\r/g, '\\n');\n}\n\nexport let CodeEditorComponent = /*#__PURE__*/(() => {\n  class CodeEditorComponent {\n    constructor(_differs, _ngZone) {\n      this._differs = _differs;\n      this._ngZone = _ngZone;\n      /* class applied to the created textarea */\n\n      this.className = '';\n      /* name applied to the created textarea */\n\n      this.name = 'codemirror';\n      /* autofocus setting applied to the created textarea */\n\n      this.autoFocus = false;\n      /* preserve previous scroll position after updating value */\n\n      this.preserveScrollPosition = false;\n      /* called when the text cursor is moved */\n\n      this.cursorActivity = new EventEmitter();\n      /* called when the editor is focused or loses focus */\n\n      this.focusChange = new EventEmitter();\n      /* called when the editor is scrolled */\n\n      this.scroll = new EventEmitter();\n      this.value = '';\n      this.disabled = false;\n      this.isFocused = false;\n      /** Implemented as part of ControlValueAccessor. */\n\n      this.onChange = _ => {};\n      /** Implemented as part of ControlValueAccessor. */\n\n\n      this.onTouched = () => {};\n    }\n    /**\r\n     * set options for codemirror\r\n     * @link http://codemirror.net/doc/manual.html#config\r\n     */\n\n\n    set options(value) {\n      this._options = value;\n\n      if (!this._differ && value) {\n        this._differ = this._differs.find(value).create();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (!this.ref) {\n        return;\n      } // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors\n\n\n      const {\n        fromTextArea\n      } = require('codemirror');\n\n      this._ngZone.runOutsideAngular(() => {\n        this.codeMirror = fromTextArea(this.ref.nativeElement, this._options);\n        this.codeMirror.on('cursorActivity', cm => this._ngZone.run(() => this.cursorActive(cm)));\n        this.codeMirror.on('scroll', this.scrollChanged.bind(this));\n        this.codeMirror.on('blur', () => this._ngZone.run(() => this.focusChanged(false)));\n        this.codeMirror.on('focus', () => this._ngZone.run(() => this.focusChanged(true)));\n        this.codeMirror.on('change', (cm, change) => this._ngZone.run(() => this.codemirrorValueChanged(cm, change)));\n        this.codeMirror.setValue(this.value);\n      });\n    }\n    /*ngDoCheck() {\r\n      if (!this._differ) {\r\n        return;\r\n      }\r\n      // check options have not changed\r\n      const changes = this._differ.diff(this._options);\r\n      if (changes) {\r\n        changes.forEachChangedItem((option: KeyValueChangeRecord<any, any>) => this.setOptionIfChanged(option.key, option.currentValue));\r\n        changes.forEachAddedItem(option => this.setOptionIfChanged(option.key, option.currentValue));\r\n        changes.forEachRemovedItem(option => this.setOptionIfChanged(option.key, option.currentValue));\r\n      }\r\n    }*/\n\n\n    ngOnDestroy() {\n      // is there a lighter-weight way to remove the cm instance?\n      if (this.codeMirror) {\n        this.codeMirror.toTextArea();\n      }\n    }\n\n    codemirrorValueChanged(cm, change) {\n      if (change.origin !== 'setValue') {\n        this.value = cm.getValue();\n        this.onChange(this.value);\n      }\n    }\n\n    setOptionIfChanged(optionName, newValue) {\n      if (!this.codeMirror) {\n        return;\n      }\n\n      this.codeMirror.setOption(optionName, newValue);\n    }\n\n    focusChanged(focused) {\n      this.onTouched();\n      this.isFocused = focused;\n      this.focusChange.emit(focused);\n    }\n\n    scrollChanged(cm) {\n      this.scroll.emit(cm.getScrollInfo());\n    }\n\n    cursorActive(cm) {\n      this.cursorActivity.emit(cm);\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    writeValue(value) {\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      if (!this.codeMirror) {\n        this.value = value;\n        return;\n      }\n\n      const cur = this.codeMirror.getValue();\n\n      if (value !== cur && normalizeLineEndings(cur) !== normalizeLineEndings(value)) {\n        this.value = value;\n\n        if (this.preserveScrollPosition) {\n          const prevScrollPosition = this.codeMirror.getScrollInfo();\n          this.codeMirror.setValue(this.value);\n          this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);\n        } else {\n          this.codeMirror.setValue(this.value);\n        }\n      }\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.setOptionIfChanged('readOnly', this.disabled);\n    }\n\n  }\n\n  CodeEditorComponent.ɵfac = function CodeEditorComponent_Factory(t) {\n    return new (t || CodeEditorComponent)(i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  CodeEditorComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: CodeEditorComponent,\n    selectors: [[\"tda-code-editor\"]],\n    viewQuery: function CodeEditorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ref = _t.first);\n      }\n    },\n    inputs: {\n      className: \"className\",\n      name: \"name\",\n      autoFocus: \"autoFocus\",\n      options: \"options\",\n      preserveScrollPosition: \"preserveScrollPosition\"\n    },\n    outputs: {\n      cursorActivity: \"cursorActivity\",\n      focusChange: \"focusChange\",\n      scroll: \"scroll\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CodeEditorComponent),\n      multi: true\n    }])],\n    decls: 2,\n    vars: 5,\n    consts: [[\"autocomplete\", \"off\", 3, \"name\", \"autofocus\"], [\"ref\", \"\"]],\n    template: function CodeEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"textarea\", 0, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.className);\n        i0.ɵɵproperty(\"name\", ctx.name)(\"autofocus\", ctx.autoFocus);\n      }\n    },\n    styles: [\"\"],\n    changeDetection: 0\n  });\n  return CodeEditorComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}